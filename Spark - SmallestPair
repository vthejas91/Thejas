package Operations.SmallPair;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import org.apache.spark.SparkConf;
import org.apache.spark.SparkContext;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.FlatMapFunction;
import org.apache.spark.api.java.function.Function;
import org.apache.spark.api.java.function.Function2;
import org.apache.spark.api.java.function.PairFunction;
import org.apache.spark.broadcast.Broadcast;

import scala.Tuple2;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        
    	String inputFilePath = args[0];
        String outputFilePath = args[1];
    	
        SparkConf conf = new SparkConf().setAppName("ClosestPair");
        JavaSparkContext sc = new JavaSparkContext(new SparkContext());
        
        JavaRDD<String> inputCsv = sc.textFile(inputFilePath);
        

        JavaRDD<String> headerLessInputCsv = inputCsv.filter(
        		new Function<String, Boolean>()
        		{
        			
        			/**
					 * 
					 */
					private static final long serialVersionUID = 1L;

					public Boolean call(String s){ 
						s = s.trim();
						if(s.equals("") ||s==null|| s.isEmpty() || s.contains("x"))
						return false;
					else
						return true;
							}
        		}
        		
        		);

         JavaPairRDD<Integer,Coordinate> points = headerLessInputCsv.mapToPair(new PairFunction<String,Integer,Coordinate>()
        		 {

					/**
					 * 
					 */
					private static final long serialVersionUID = 1L;

					public Tuple2<Integer,Coordinate> call(String s)
							throws Exception {
						// TODO Auto-generated method stub
						String[] y = s.split(",");
						int i = 0;
						i++;
						Coordinate pt = new Coordinate();
						pt.setX(Double.parseDouble(y[0]));
						pt.setY(Double.parseDouble(y[1]));
						
						return new Tuple2<Integer,Coordinate>(i,pt);
					}
        	 
        		 });
         
         JavaPairRDD<Integer, Iterable<Coordinate>> point = points.groupByKey();
         
         JavaRDD<Iterable<Coordinate>> val = point.values();
         

         
         JavaRDD<Coordinate> closePair = val.map(new Function<Iterable<Coordinate>,Coordinate>()
        		 {

					/**
					 * 
					 */
					private static final long serialVersionUID = 1L;

					public Coordinate call(Iterable<Coordinate> input)
							throws Exception {
						List<Coordinate> pts = new ArrayList<Coordinate>();
						List<Coordinate> closepoints = new ArrayList<Coordinate>();

						Iterator<Coordinate> Iter;
						Double dist = 10.0; 
						Double xdiff;
						Double ydiff; 						
						Double distance;
						Coordinate first = null;
						Coordinate second  = null;
						
						Iter = input.iterator();
						while(Iter.hasNext())
						{
							pts.add(Iter.next());
						}
						
						for(Coordinate cand: pts)
						{
							distance = 0.0;
							for(Coordinate cand1: pts)
							{
								xdiff = cand.getX() - cand1.getX();
    							ydiff = cand.getY() - cand1.getY();
    							if (xdiff == 0.0 && ydiff == 0.0)
    							{
    								continue;
    							}
    							distance = Math.sqrt((xdiff * xdiff) + (ydiff * ydiff));
    							if (distance < dist)
    							{
    								dist = distance;
    								first = cand;
    								second = cand1;
    							}
    						}
    					}
						closepoints.add(first);
						closepoints.add(second);
						
					System.out.println("FIRST "+first.getX()+"  "+first.getY());
					System.out.println("SECOND "+second.getX()+"  "+second.getY());
										
						
						
						// TODO Auto-generated method stub
						return null;
					}
        	 
					
					
        		 });
              
         
         
         
         
         closePair.saveAsTextFile(outputFilePath);
         
         
        		     	
    }
}
